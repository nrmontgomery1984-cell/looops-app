// Decision Export Functions
// Export decision summaries to CSV or clipboard

import {
  Decision,
  DecisionSurvey,
  FeelingScore,
  LoopId,
  getFeelingLabel,
} from "../../types";
import { CoachingSummary } from "./coaching";

interface ExportableDecision {
  title: string;
  loop: LoopId;
  survey: DecisionSurvey;
  confidenceLevel: number;
  finalChoice: "proceed" | "decline" | "defer";
  coachingSummary?: CoachingSummary | null;
}

/**
 * Generate a formatted markdown summary of a decision
 */
export function generateMarkdownSummary(decision: ExportableDecision): string {
  const { title, loop, survey, confidenceLevel, finalChoice, coachingSummary } = decision;

  const choiceLabel = {
    proceed: "Proceeding",
    decline: "Declining",
    defer: "Deferring",
  }[finalChoice];

  const feelingLabel = getFeelingLabel(survey.feelingScore);

  let markdown = `# Decision Summary

## ${title}

**Life Area:** ${loop}
**Decision:** ${choiceLabel}
**Confidence:** ${confidenceLevel}/10
**Date:** ${new Date().toLocaleDateString()}

---

## Emotional State
${feelingLabel} (${survey.feelingScore}/5 on Fear-Greed spectrum)

---

## The Joust

**FOR:** ${survey.oneReason}

**AGAINST:** ${survey.reasonAgainst}

**Winner:** ${survey.joustWinner === "for" ? "FOR" : "AGAINST"}

---

## Quality Check
- Honest: ${survey.isHonest ? "Yes" : "No"}
- Concise: ${survey.isConcise ? "Yes" : "No"}
- Values-Aligned: ${survey.isTiedToValues ? "Yes" : "No"}

---

## Context

**Trigger:** ${survey.trigger}

**Alternatives Considered:** ${survey.alternativesConsidered.length > 0 ? survey.alternativesConsidered.join(", ") : "None listed"}

**Valid Substitutes:** ${survey.validSubstitutes || "None identified"}

**Would do without secondary benefits:** ${survey.withoutSecondaryBenefits ? "Yes" : "No"}

---

## Stakes

**Reversibility:** ${survey.isReversible ? "Reversible (Two-Way Door)" : "Irreversible (One-Way Door)"}

**Upside if Right:** ${survey.upsideIfRight}

**Downside if Wrong:** ${survey.downsideIfWrong}

`;

  if (coachingSummary) {
    markdown += `---

## Coaching Analysis

**Overall Risk:** ${coachingSummary.overallRisk}

**Recommendation:** ${formatRecommendation(coachingSummary.recommendedAction)}

`;

    if (coachingSummary.topConcerns.length > 0) {
      markdown += `**Concerns:**
${coachingSummary.topConcerns.map(c => `- ${c}`).join("\n")}

`;
    }

    if (coachingSummary.strengthsNoted.length > 0) {
      markdown += `**Strengths:**
${coachingSummary.strengthsNoted.map(s => `- ${s}`).join("\n")}

`;
    }
  }

  markdown += `---

*Generated by Looops Decision Coach*
*https://looops-app.vercel.app/coach*
`;

  return markdown;
}

function formatRecommendation(action: CoachingSummary["recommendedAction"]): string {
  const labels: Record<CoachingSummary["recommendedAction"], string> = {
    proceed_confidently: "Proceed with confidence",
    proceed_cautiously: "Proceed, but stay alert",
    pause_and_reflect: "Pause and address the concerns",
    wait_48h: "Wait 48 hours before finalizing",
    gather_more_info: "Gather more information first",
  };
  return labels[action];
}

/**
 * Generate CSV content for a decision
 */
export function generateCSV(decision: ExportableDecision): string {
  const { title, loop, survey, confidenceLevel, finalChoice, coachingSummary } = decision;

  // CSV header and data rows
  const rows = [
    ["Field", "Value"],
    ["Decision", title],
    ["Life Area", loop],
    ["Final Choice", finalChoice],
    ["Confidence Level", confidenceLevel.toString()],
    ["Date", new Date().toISOString()],
    ["", ""],
    ["Emotional State", ""],
    ["Feeling Score", `${survey.feelingScore}/5`],
    ["Feeling Label", getFeelingLabel(survey.feelingScore)],
    ["", ""],
    ["The Joust", ""],
    ["Reason FOR", survey.oneReason],
    ["Reason AGAINST", survey.reasonAgainst],
    ["Joust Winner", survey.joustWinner],
    ["", ""],
    ["Quality Check", ""],
    ["Is Honest", survey.isHonest ? "Yes" : "No"],
    ["Is Concise", survey.isConcise ? "Yes" : "No"],
    ["Is Values-Aligned", survey.isTiedToValues ? "Yes" : "No"],
    ["", ""],
    ["Context", ""],
    ["Trigger", survey.trigger],
    ["Alternatives Considered", survey.alternativesConsidered.join("; ")],
    ["Valid Substitutes", survey.validSubstitutes || "None"],
    ["Would Do Without Extras", survey.withoutSecondaryBenefits ? "Yes" : "No"],
    ["", ""],
    ["Stakes", ""],
    ["Is Reversible", survey.isReversible ? "Yes" : "No"],
    ["Upside If Right", survey.upsideIfRight],
    ["Downside If Wrong", survey.downsideIfWrong],
  ];

  if (coachingSummary) {
    rows.push(
      ["", ""],
      ["Coaching Analysis", ""],
      ["Overall Risk", coachingSummary.overallRisk],
      ["Recommendation", formatRecommendation(coachingSummary.recommendedAction)],
      ["Top Concerns", coachingSummary.topConcerns.join("; ")],
      ["Strengths Noted", coachingSummary.strengthsNoted.join("; ")]
    );
  }

  // Convert to CSV format with proper escaping
  return rows
    .map(row =>
      row
        .map(cell => {
          // Escape quotes and wrap in quotes if contains comma, newline, or quote
          const escaped = cell.replace(/"/g, '""');
          if (escaped.includes(",") || escaped.includes("\n") || escaped.includes('"')) {
            return `"${escaped}"`;
          }
          return escaped;
        })
        .join(",")
    )
    .join("\n");
}

/**
 * Copy text to clipboard
 */
export async function copyToClipboard(text: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch (err) {
    // Fallback for older browsers
    const textArea = document.createElement("textarea");
    textArea.value = text;
    textArea.style.position = "fixed";
    textArea.style.left = "-9999px";
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    try {
      document.execCommand("copy");
      document.body.removeChild(textArea);
      return true;
    } catch (e) {
      document.body.removeChild(textArea);
      return false;
    }
  }
}

/**
 * Download CSV file
 */
export function downloadCSV(decision: ExportableDecision, filename?: string): void {
  const csv = generateCSV(decision);
  const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
  const url = URL.createObjectURL(blob);

  const link = document.createElement("a");
  link.href = url;
  link.download = filename || `decision-${slugify(decision.title)}-${formatDate(new Date())}.csv`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-|-$/g, "")
    .substring(0, 30);
}

function formatDate(date: Date): string {
  return date.toISOString().split("T")[0];
}
